"""
Utility functions for TLS Fragment - Optimized for OpenWrt
"""

import struct
import random
import socket

def extract_sni(data):
    """Extract SNI from TLS ClientHello"""
    try:
        if len(data) < 5:
            return None
            
        # Parse TLS record
        content_type, version, length = struct.unpack('>BBH', data[:4])
        if content_type != 0x16:  # Handshake
            return None
            
        # Parse handshake
        if len(data) < 9:
            return None
            
        handshake_type = data[5]
        if handshake_type != 0x01:  # ClientHello
            return None
            
        # Skip to extensions
        offset = 43  # Skip fixed fields
        if offset >= len(data):
            return None
            
        # Skip session ID
        session_id_len = data[offset]
        offset += 1 + session_id_len
        
        if offset + 2 >= len(data):
            return None
            
        # Skip cipher suites
        cipher_suites_len = struct.unpack('>H', data[offset:offset+2])[0]
        offset += 2 + cipher_suites_len
        
        if offset >= len(data):
            return None
            
        # Skip compression methods
        compression_len = data[offset]
        offset += 1 + compression_len
        
        if offset + 2 >= len(data):
            return None
            
        # Parse extensions
        extensions_len = struct.unpack('>H', data[offset:offset+2])[0]
        offset += 2
        
        end_offset = offset + extensions_len
        while offset < end_offset and offset + 4 <= len(data):
            ext_type, ext_len = struct.unpack('>HH', data[offset:offset+4])
            offset += 4
            
            if ext_type == 0x0000:  # SNI extension
                if offset + ext_len <= len(data):
                    sni_data = data[offset:offset+ext_len]
                    if len(sni_data) >= 5:
                        name_len = struct.unpack('>H', sni_data[3:5])[0]
                        if len(sni_data) >= 5 + name_len:
                            return sni_data[5:5+name_len].decode('utf-8')
                            
            offset += ext_len
            
        return None
        
    except Exception:
        return None

def fragment_tls_data(data, sni, num_pieces, sni_len):
    """Fragment TLS data"""
    try:
        if not sni or len(data) < 5:
            return [data]
            
        # Find SNI position
        sni_bytes = sni.encode('utf-8')
        sni_pos = data.find(sni_bytes)
        
        if sni_pos == -1:
            return [data]
            
        # Create fragments
        fragments = []
        
        # Before SNI
        if sni_pos > 0:
            fragments.append(data[:sni_pos])
            
        # SNI fragments
        remaining_sni = len(sni_bytes)
        pos = sni_pos
        
        while remaining_sni > 0:
            chunk_size = min(sni_len, remaining_sni)
            fragments.append(data[pos:pos+chunk_size])
            pos += chunk_size
            remaining_sni -= chunk_size
            
        # After SNI
        if pos < len(data):
            fragments.append(data[pos:])
            
        return fragments
        
    except Exception:
        return [data]

def parse_socks5_address(sock):
    """Parse SOCKS5 address"""
    atyp = sock.recv(1)[0]
    
    if atyp == 0x01:  # IPv4
        addr = socket.inet_ntop(socket.AF_INET, sock.recv(4))
        port = struct.unpack('>H', sock.recv(2))[0]
        return addr, port
    elif atyp == 0x03:  # Domain
        domain_len = sock.recv(1)[0]
        domain = sock.recv(domain_len).decode('utf-8')
        port = struct.unpack('>H', sock.recv(2))[0]
        return domain, port
    elif atyp == 0x04:  # IPv6
        addr = socket.inet_ntop(socket.AF_INET6, sock.recv(16))
        port = struct.unpack('>H', sock.recv(2))[0]
        return addr, port
    else:
        raise ValueError("Invalid address type")
