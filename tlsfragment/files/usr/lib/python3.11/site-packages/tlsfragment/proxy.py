"""
Proxy handler for TLS Fragment - Optimized for OpenWrt
"""

import socket
import threading
import time
import logging
import struct
from .utils import extract_sni, fragment_tls_data, parse_socks5_address
from .dns_resolver import DNSResolver

logger = logging.getLogger(__name__)

class ProxyHandler:
    def __init__(self, client_sock, config):
        self.client_sock = client_sock
        self.config = config
        self.dns_resolver = DNSResolver(config)
        
    def handle(self):
        """Handle client connection"""
        try:
            self.client_sock.settimeout(self.config.socket_timeout)
            
            # Detect protocol
            initial_data = self.client_sock.recv(5, socket.MSG_PEEK)
            if not initial_data:
                return
                
            if initial_data[0] == 0x05:  # SOCKS5
                self._handle_socks5()
            else:  # HTTP
                self._handle_http()
                
        except Exception as e:
            logger.debug(f"Connection error: {e}")
        finally:
            self.client_sock.close()
            
    def _handle_socks5(self):
        """Handle SOCKS5 connection"""
        try:
            # SOCKS5 handshake
            version = self.client_sock.recv(1)[0]
            if version != 0x05:
                return
                
            nmethods = self.client_sock.recv(1)[0]
            methods = self.client_sock.recv(nmethods)
            
            # Send no authentication required
            self.client_sock.sendall(b'\x05\x00')
            
            # Read connection request
            data = self.client_sock.recv(4)
            if len(data) != 4 or data[0] != 0x05:
                return
                
            cmd = data[1]
            if cmd != 0x01:  # Only support CONNECT
                self.client_sock.sendall(b'\x05\x07\x00\x01\x00\x00\x00\x00\x00\x00')
                return
                
            # Parse target address
            target_host, target_port = parse_socks5_address(self.client_sock)
            
            # Connect to target
            if self._connect_target(target_host, target_port):
                self.client_sock.sendall(b'\x05\x00\x00\x01\x00\x00\x00\x00\x00\x00')
                self._relay_data()
            else:
                self.client_sock.sendall(b'\x05\x04\x00\x01\x00\x00\x00\x00\x00\x00')
                
        except Exception as e:
            logger.debug(f"SOCKS5 error: {e}")
            
    def _handle_http(self):
        """Handle HTTP CONNECT"""
        try:
            data = self.client_sock.recv(4096)
            if not data.startswith(b'CONNECT '):
                return
                
            # Parse CONNECT request
            lines = data.decode().split('\r\n')
            connect_line = lines[0]
            target = connect_line.split()[1]
            
            if ':' in target:
                target_host, target_port = target.rsplit(':', 1)
                target_port = int(target_port)
            else:
                target_host = target
                target_port = 443
                
            # Connect to target
            if self._connect_target(target_host, target_port):
                self.client_sock.sendall(b'HTTP/1.1 200 Connection established\r\n\r\n')
                self._relay_data()
            else:
                self.client_sock.sendall(b'HTTP/1.1 502 Bad Gateway\r\n\r\n')
                
        except Exception as e:
            logger.debug(f"HTTP error: {e}")
            
    def _connect_target(self, host, port):
        """Connect to target server"""
        try:
            # Resolve hostname if needed
            if not self._is_ip(host):
                host = self.dns_resolver.resolve(host)
                if not host:
                    return False
                    
            # Create target socket
            self.target_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.target_sock.settimeout(self.config.socket_timeout)
            self.target_sock.connect((host, port))
            
            self.target_host = host
            self.target_port = port
            
            return True
            
        except Exception as e:
            logger.debug(f"Target connection error: {e}")
            return False
            
    def _relay_data(self):
        """Relay data between client and target"""
        def client_to_target():
            try:
                first_packet = True
                while True:
                    data = self.client_sock.recv(4096)
                    if not data:
                        break
                    if first_packet and self._should_fragment():
                        self._send_fragmented(data)
                        first_packet = False
                    else:
                        self.target_sock.sendall(data)
            except Exception as e:
                logger.debug(f"Client to target relay error: {e}")
            finally:
                try:
                    self.target_sock.close()
                except:
                    pass

        def target_to_client():
            try:
                while True:
                    data = self.target_sock.recv(4096)
                    if not data:
                        break
                    self.client_sock.sendall(data)
            except Exception as e:
                logger.debug(f"Target to client relay error: {e}")
            finally:
                try:
                    self.client_sock.close()
                except:
                    pass

        # Start relay threads
        t1 = threading.Thread(target=client_to_target, daemon=True)
        t2 = threading.Thread(target=target_to_client, daemon=True)
        t1.start()
        t2.start()
        t1.join()
        t2.join()
        
    def _should_fragment(self):
        """Check if we should fragment this connection"""
        return (self.config.mode == 'TLSfrag' and 
                self.config.should_proxy_domain(self.target_host))
                
    def _send_fragmented(self, data):
        """Send data with TLS fragmentation"""
        try:
            sni = extract_sni(data)
            if sni and self.config.mode == 'TLSfrag':
                fragments = fragment_tls_data(
                    data, sni, 
                    self.config.num_tls_pieces,
                    self.config.len_tls_sni
                )
                
                for fragment in fragments:
                    self.target_sock.sendall(fragment)
                    time.sleep(self.config.send_interval)
            else:
                self.target_sock.sendall(data)
                
        except Exception as e:
            logger.debug(f"Fragmentation error: {e}")
            self.target_sock.sendall(data)
            
    def _is_ip(self, addr):
        """Check if address is an IP"""
        try:
            socket.inet_aton(addr)
            return True
        except socket.error:
            return False
